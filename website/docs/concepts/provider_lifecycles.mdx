---
title: Provider Lifecycles
---

## When does my Provider get created and disposed?

The states that all different types of providers can go through are the same:

- Uninitialized
- Creating
- Alive
- Disposing

### Uninitialized

An uninitialized provider does not take up any memory since its state is not initialized.
It will stay that way until an Alive provider or the UI reads or watches it.

### Creating -> Alive

When an uninitialized provider is being read or watched it will be created.

When a provider is created your provider creation function will be run. Any
providers that you read or watch will be created as needed and their state will be retrieved.

If there are any circular dependencies during this creation process Riverpod will throw an error.
The best way to fix this error is to redesign your dependencies to have a uni-directional dataflow.

The provider's state is stored in a [ProviderContainer]. In a Flutter app this container is in a [ProviderScope] widget.


:::warning
Do not create a ProviderContainer for use in flutter unless using [UncontrolledProviderScope] and you know what you are doing.
:::

### Alive

When your provider is Alive, changes to its state will cause dependent providers and/or the dependent UI to rebuild.

### Alive -> Disposing

Providers are not necessarily automatically disposed, and this is where many developers run into issues and questions.

There are two ways for a provider to be disposed.

- When defined using the .autoDispose modifier and no longer being watched by the UI or another provider
- When the provider is being recreated due to a change in another provider that was watched within the current provider's create function
  Learn more about this second case by reading [Combining Providers](/docs/concepts/combining_providers)

In both cases you can register actions that will happen before the provider is disposed using `ref.onDispose`.
A disposed provider is in the uninitialized state again, and will be created on demand when the provider is watched or read again.

## Performing actions before the state destruction

In some cases, the state of a provider may get destroyed or re-created.
A common requirement in those situations is to perform a cleanup before the state of a provider
is destroyed, such as closing a [StreamController].

This is done using the `ref`'s [onDispose] method.

The following example uses onDispose to close a StreamController:

```dart
final example = StreamProvider.autoDispose((ref) {
  final streamController = StreamController<int>();

  ref.onDispose(() {
    // Closes the StreamController when the state of this provider is destroyed.
    streamController.close();
  });

  return streamController.stream;
});
```

:::note
Depending on the provider used, it may already take care of the clean-up process.
For example, [StateNotifierProvider] will call the `dispose` method of the returned [StateNotifier].
:::

[onDispose]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderRef/onDispose.html
[ProviderContainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[ProviderScope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[StateNotifier]: https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html
[StateNotifierProvider]: https://pub.dev/documentation/riverpod/latest/riverpod/StateNotifierProvider-class.html
[StreamController]: https://api.dart.dev/stable/2.15.1/dart-async/StreamController-class.html
[UncontrolledProviderScope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/UncontrolledProviderScope-class.html

---
title: Provider Lifecycles
---

## When does my Provider get created and disposed?

The states that all different types of providers can go through are the same:

- Disposed / Uninitialized
- Creating
- Alive

### Disposed / Uninitialized

An uninitialized provider does not take up any memory since its state is not initialized.
Essentially it is just a definition of how to create state when a widget needs it.
It will stay that way until an Alive provider or the UI reads or watches it.

### Creating -> Alive

When an uninitialized provider is being read or watched it will be created.

When a provider is created your provider creation function will be run. Any
providers that you read or watch will be created as needed and their state will be retrieved.

If there are any circular dependencies during this creation process Riverpod will throw an error.
The best way to fix this error is to redesign your dependencies to have a uni-directional dataflow.

The provider's state is stored in a [ProviderContainer]. In a Flutter app this container is in a [ProviderScope] widget.

### Alive

When your provider is Alive, changes to its state will cause dependent providers and/or the dependent UI to rebuild.

### Alive -> Disposing

There are a few ways for a provider to be disposed.

- When defined using the `.autoDispose` modifier and no longer being watched by the UI or another provider
- When the provider is being recreated due to a change in another provider that was watched within the current provider's create function.
  Learn more about this second case by reading [Combining Providers](/docs/concepts/combining_providers)
- When the provider is being manually refreshed or invalidated. 

Refreshing causes the provider to immediately go through the creation process again, whereas invalidating causes the next read / watch of the provider to cause the provider to be rebuilt.


## Performing actions before the state destruction
You can register actions that will happen before the provider is disposed using `ref.onDispose`.

This is done using the `ref`'s [onDispose] method.

The following example uses onDispose to close a StreamController:

```dart
final example = StreamProvider.autoDispose((ref) {
  final streamController = StreamController<int>();

  ref.onDispose(() {
    // Closes the StreamController when the state of this provider is destroyed.
    streamController.close();
  });

  return streamController.stream;
});
```

:::note
Depending on the provider used, it may already take care of the clean-up process.
For example, [StateNotifierProvider] will call the `dispose` method of the returned [StateNotifier].
:::

[onDispose]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderRef/onDispose.html
[ProviderContainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[ProviderScope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[StateNotifier]: https://pub.dev/documentation/state_notifier/latest/state_notifier/StateNotifier-class.html
[StateNotifierProvider]: https://pub.dev/documentation/riverpod/latest/riverpod/StateNotifierProvider-class.html
[StreamController]: https://api.dart.dev/stable/2.15.1/dart-async/StreamController-class.html

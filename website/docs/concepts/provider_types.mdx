## Different Types of Providers

There are multiple types of providers for multiple different use cases.

With all of these providers available, it is sometimes difficult to understand when to use one provider type over another.
Use the table below to choose a provider that fits what you want to provide to the widget tree.

| Provider Type          | Provider Create Function             | Example Use Case                                                     |
| ---------------------- | ------------------------------------ | -------------------------------------------------------------------- |
| Provider               | Returns any type                     | A service class / computed property (filtered list)                  |
| StateProvider          | Returns any type                     | A filter condition / simple state object                             |
| FutureProvider         | Returns a Future of any type         | A result from an API call                                            |
| StreamProvider         | Returns a Stream of any type         | A stream of results from an API                                      |
| StateNotifierProvider  | Returns a subclass of StateNotifier  | A complex state object that is immutable except through an interface |
| ChangeNotifierProvider | Returns a subclass of ChangeNotifier | A complex state object that requires mutability                      |

The best way to understand how you can use providers is to see a few examples of them in different use cases.

As such, finding and following tutorials will be most beneficial to learning how to use different providers. However, here are a few examples:

```dart
// Regular Provider
final apiUrlProvider = Provider<String>((ref) => 'https://example.com');

// State Providers
enum Filter {completed, uncompleted, all}
final todoFilterProvider = StateProvider<Filter>((ref) => Filter.all);
final errorMessageProvider = StateProvider<String>((ref) => null);

// Future Provider
final allTodosProvider = FutureProvider<List<Todo>>((ref) async {
  final url = ref.watch(apiUrlProvider);
  final todos = await http.get(url);
  return json.decode(todos).map((t) => Todo.fromJson(t));
});

// Stream Provider
final counterProvider = StreamProvider<int>((ref) async* {
  for (var i = 0; i < 100; i++){
    yield i;
    await Future.delayed(Duration(seconds: 1));
  }
});

// StateNotifier Provider
final configProvider = StateNotifierProvider<Config>((ref) => Config(ref.read));

class Config extends StateNotifierProvider<ConfigState> {
  Config(this.read): super(const ConfigState.initial());
  Reader read;

  void setDarkMode(bool value) {
    state = state.copyWith(darkMode: value);
  }

  Future<void> setBackUpOverCellData(bool overData) async {
    state = state.copyWith(backUpOverCellData: overData);
    if (overData){
      if (read(connectivityProvider).connectivity == ConnectivityResult.mobile){
        // Need to initiate a sync now that backing up is enabled on mobile network
        final url = read(apiUrlProvider);
        try {
          await http.post(url, body: {'data' : "I'm backing up something"});
        } catch (e){
          read(errorMessageProvider).state = 'Backup failed, is your internet enabled?';
        }
      }
    }
  }
}

@freezed
abstract class ConfigState with _$ConfigState {
  const factory ConfigState.initial() => ConfigState(darkMode: false, backUpOverCellData: false);
  const factory ConfigState({bool darkMode, bool backUpOverCellData}) = _ConfigState;
}

// ChangeNotifier Provider
final connectivityProvider = ChangeNotifierProvider((ref) => ConnectivityProvider());

final ConnectivityProvider extends ChangeNotifier {
  ConnectivityProvider(){
    _subscription = Connectivity().onConnectivityChanged((status) {
      connectivity = status;
      notifyListeners();
    });
  }
  final StreamSubscription<ConnectivityResult> _subscription;

  ConnectivityResult connectivity;

  @override
  void dispose() {
    _subscription.cancel();
  }
}

```

## What are the differences between providers?

### Provider

Provides a simple dart object.

### StateProvider

Provides a dart object that can be changed and accessed externally, such as in the widget tree.

Reading or watching this provider will give you the current state of this provider, causing watchers to rebuild
when that state updates.

Reading or watching the `.state` property of this provider will give you access to a `StateController`
which has a `.state` getter and setter that you can use to read the current state of the
provider or set the new state and notify all the Provider's watchers.

Reading or watching the `.notifier` property will only cause the watcher to rebuild when the
provider's creation function reruns as a result of one of it's dependent providers changing.

### FutureProvider

Has the ability to run async functions.

Helpful for storing results from an API.

Reading or watching this provider will return you an `AsyncValue` which is a union class
that has three states: `AsyncValue.data`, `AsyncValue.error`, and AsyncValue.loading`.

`AyncValue.data` is an instance of `AsyncData` which contains a `.data` property that is the current data, or null if the union is in the loading or error states.

A `FutureProvider` instance has a `.future` property that you can use to use to get a `Future` if you prefer to use a `FutureBuilder`
or need access to the future in some other repository or data store provider class.
For example this snippet obtains a Future that resolves to future provided by myFutureProvider:

```dart
final result = await ref.read(myFutureProvider.future);
```

### StreamProvider

Provides the ability to provide streams of data to the UI.

Useful for various data APIs that are asynchronous, socket based or push based.

Reading or watching this provider will return an `AsyncValue` just as the `FutureProvider`.

Additionally an instance of `StreamProvider` has a property `.last` that you can read or watch
to get a future that resolves to the last element emitted from the stream.
The reason it is a future, is because the stream might not have emitted anything yet.

You can get a reference to the stream itself by reading or watching the `.stream` property. This is a
broadcast stream, so it can be listened to multiple times.

### StateNotifierProvider

Provides a subclass of [StateNotifier].

Reading or watching the provider will return the state of the [StateNotifier].
Watchers rebuild anytime the state is set.
Reading or watching the `.notifier` property will return the subclass of [StateNotifier].
Watchers rebuild only when the instance of the [StateNotifier] has changed.

Setting the state of the [StateNotifier] will notify all watchers of the [StateNotifier]'s state.

State notifier classes should have methods defined to set the new state.
The state is not assignable outside the class to encourage good encapsulation principles. If you
want a simple state that is settable outside of the class use [StateProvider] instead.

### ChangeNotifierProvider

Provides a subclass or implementer of `ChangeNotifier`.

Reading or watching this provider will return the subclass of [ChangeNotifier]. 
Watchers will rebuild anytime `notifyListeners()` is called.
Reading or watching the `.notifier` property will return the subclass of [ChangeNotifier]. 
Watchers will rebuild if the [ChangeNotifier] instance has changed.

Calling `notifyListeners()` inside of the `ChangeNotifier` will notify all watchers of the `ChangeNotifier`'s state.

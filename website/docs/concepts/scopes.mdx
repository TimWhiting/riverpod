---
title: Scopes
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Scoping in riverpod is an important thing to understand.

Many issues that developers have with riverpod come from misunderstanding scope.

## Container Scope

A scope is introduced by a `ProviderContainer`. This container holds the current state of
all of your providers. It manages the lookup and subscriptions between providers.

In Flutter you should use the `ProviderScope` widget, which contains a `ProviderContainer`
internally, and provides a way to access that container to the rest of the widget tree.

```dart
final valueProvider = StateProvider((ref) => 0);

// DO this
void main() {
  runApp(ProviderScope(child: MyApp()));
}

//DON'T do this:
final myProviderContainer = ProviderContainer();
void main(){
  runApp(MyApp());
}
```

:::warning
Do not use multiple `ProviderContainers`. Each will have it's own separate thread of states, which will not be able to access each other.
You will quickly become disoriented and confused.
:::

A `ProviderContainer` by itself should only be utilized for testing and dart-only usage.
In Flutter it should not be used, unless you have a need for asynchronous initialization prior
to showing any screens. For asynchronous concerns see the [asynchronous cookbook](/docs/cookbooks/asynchrony)

## Scoping Providers to a Widget Subtree

All providers can be scoped to a widget subtree. However, there are some things to keep in mind while doing so.

The easiest way to understand this provider scoping is to see an example of a todo list.

```dart
/// A simple Todo class
class Todo {
  Todo(this.todo);
  final String todo;
}

/// Provides a list of [Todo]s.
final todoListProvider = StateProvider<List<Todo>>(
    (ref) => [Todo('this'), Todo('that'), Todo('the other')]);

/// Provides the index for a todo in a particular portion
/// of the widget tree
final todoItemIndexProvider = Provider<int>((ref) =>
    throw UnimplementedError('Todo index not set'));

/// Widget for the whole todo list
class TodoListWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final length = ref.watch(todoListProvider.select((list) => list.length));
    print('Build List');
    return ListView.builder(
      itemCount: length,
      itemBuilder: (context, index) {
        // Overrides the todoItemIndexProvider
        // for everything below this in the tree
        return ProviderScope(
          overrides: [
            todoItemIndexProvider.overrideWithValue(index),
          ],
          // Using this approach, TodoWidget can now be constant
          // since no index needs to be passed down
          child: const TodoWidget(),
        );
      },
    );
  }
}

/// Provides a single todo, so you can watch them individually
///
/// This way you will only be notified if the particular todo you
/// were watching was updated
final todoProvider = Provider.family<Todo, int>(
    (ref, index) => ref.watch(todoListProvider).state[index]);

/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Gets the index of this particular Todo
    final index = ref.watch(todoItemIndexProvider);
    print('Building Item $index');
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider(index));
    // Display it!
    return Text(todoItem.todo);
  }
}
```

Which will print

```
flutter: Build List
flutter: Build Item 0
flutter: Build Item 1
flutter: Build Item 2
// After updating item 0 in the todoListProvider by doing something like
//
// ref.read(todoListProvider).update((state) => [Todo('New Todo'), ...state.sublist(1)]);
//
// you will then see:
flutter: Build Item 0
```

Note that not all apps need to optimize performance like this. In fact this will probably not affect your performance too drastically.
Avoid premature optimization until you measure a performance impact.

However, this approach does come with some nice organizational properties,
such as keeping your widget constructors clean from an ever growing list of parameters being passed down.
Therefore it is an important tool as part of riverpod dependency injection.

## Scoping Depedent Providers

In the previous example no other provider depended on the `todoItemIndexProvider`.

Let's change the example to use a dependent provider rather than a family.

This:

```dart
/// Provides a single todo, so you can watch them individually
///
/// This way you will only be notified if the particular todo you
/// were watching was updated
final todoProvider = Provider.family<Todo, int>(
    (ref, index) => ref.watch(todoListProvider).state[index]);
```

changes to:

```dart
/// Provides a single todo based on the todoItemIndexProvider
final todoProvider = Provider<Todo>(
    (ref) => ref.watch(todoListProvider).state[ref.watch(todoItemIndexProvider)]);
```

and this:

```dart
/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Gets the index of this particular Todo
    final index = ref.watch(todoItemIndexProvider);
    print('Building Item $index');
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider(index));
    // Display it!
    return Text(todoItem.todo);
  }
}
```

changes to:

```dart
/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider);
    // Display it!
    return Text(todoItem.todo);
  }
}
```

Well if we try this with no other changes, we get an exception thrown!

```
An exception was thrown while building Provider<Todo>

Thrown exception:
An exception was thrown while building Provider<int>

Thrown exception:
UnimplementedError: Todo index not set
```

The problem is that riverpod does not know which scope to insert the
new `todoProvider` that you are trying to access in `TodoWidget`. By
default it places all providers in the root scope at the root of your
widget tree. This way you can access the same provider from all parts
of your app. But in that scope the `todoItemIndexProvider` provider is not overriden otherwise
you'd have the same todo index for the whole app.

The solution to this problem is to override the todoProvider for the subtree as well.

This:

```dart
itemBuilder: (context, index) {
        // Overrides the todoItemIndexProvider
        // for everything below this in the tree
        return ProviderScope(
          overrides: [
            todoItemIndexProvider.overrideWithValue(index),
          ],
          // Using this approach, TodoWidget can now be constant
          // since no index needs to be passed down
          child: const TodoWidget(),
        );
      },
```

changes to:

```dart
itemBuilder: (context, index) {
        // Overrides the todoItemIndexProvider
        // for everything below this in the tree
        return ProviderScope(
          overrides: [
            todoItemIndexProvider.overrideWithValue(index),
            todoProvider,
          ],
          // Using this approach, TodoWidget can now be constant
          // since no index needs to be passed down
          child: const TodoWidget(),
        );
      },
```

Hot restart your app, and everything should work! You've successfully used
scoped providers to get a unique instance of the todoProvider for each of
of the items in the `ListView`.

---
title: Scopes
---

import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";

Scoping in Riverpod is an important thing to understand.

Many issues that developers have with Riverpod come from misunderstanding scope.

## Container Scope

A scope is introduced by a [ProviderContainer]. This container holds the current state of all of your providers. 
It manages the lookup and subscriptions between providers.

In Flutter you should use the [ProviderScope] widget, which contains a [ProviderContainer]
internally, and provides a way to access that container to the rest of the widget tree.

```dart
final valueProvider = StateProvider((ref) => 0);

// DO this
void main() {
  runApp(ProviderScope(child: MyApp()));
}

//DON'T do this:
final myProviderContainer = ProviderContainer();
void main(){
  runApp(MyApp());
}
```

:::warning
Do not use multiple [ProviderContainer]s unless you are very familiar with how Riverpod works. 
Each will have it's own separate thread of states, which will not be able to access each other.
You will quickly become disoriented and confused.
:::

A [ProviderContainer] by itself should only be utilized for testing and dart-only usage.
In Flutter it should not be used, unless you have a need for asynchronous initialization prior
to showing any screens, in which case you can use it along with [UncontrolledProviderScope]

When a widget or provider requests the value of a provider riverpod finds the state of that provider in the nearest 
[ProviderScope] or if not already initialized creates it in the root [ProviderScope].

## Scoping Providers to a Widget Subtree

All providers can be scoped to a widget subtree. However, there are some things to keep in mind while doing so.

The easiest way to understand subtree scoping is to go through a todo list example with a simple scoped provider,
and refactor it to use a scoped provider with dependencies.

```dart
/// A simple Todo class
class Todo {
  Todo(this.todo);
  final String todo;
}

/// Provides a list of [Todo]s.
final todoListProvider = StateProvider<List<Todo>>(
    (ref) => [Todo('this'), Todo('that'), Todo('the other')]);

/// Provides the index for a todo in a particular portion
/// of the widget tree
final todoItemIndexProvider = Provider<int>((ref) =>
    throw UnimplementedError('Todo index not set'));

/// Widget for the whole todo list
class TodoListWidget extends ConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final length = ref.watch(todoListProvider.select((list) => list.length));
    print('Build List');
    return ListView.builder(
      itemCount: length,
      itemBuilder: (context, index) {
        // Overrides the todoItemIndexProvider
        // for everything below this in the tree
        return ProviderScope(
          overrides: [
            todoItemIndexProvider.overrideWithValue(index),
          ],
          // Using this approach, TodoWidget can now be constant
          // since no index needs to be passed down
          child: const TodoWidget(),
        );
      },
    );
  }
}

/// Provides a single todo, so you can watch them individually
///
/// This way you will only be notified if the particular todo you
/// were watching was updated
final todoProvider = Provider.family<Todo, int>(
    (ref, index) => ref.watch(todoListProvider).state[index]);

/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Gets the index of this particular Todo
    final index = ref.watch(todoItemIndexProvider);
    print('Building Item $index');
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider(index));
    // Display it!
    return Text(todoItem.todo);
  }
}

void main() {
  runApp(
    ProviderScope(
      child: MaterialApp(
        home: Scaffold(
          body: TodoListWidget(),
          floatingActionButton: Consumer(builder: (context, ref, child) {
            return FloatingActionButton(
              onPressed: () {
                ref
                    .read(todoListProvider)
                    .update((state) => [...state, Todo('New Todo')]);
              },
              child: Icon(Icons.add),
            );
          }),
        ),
      ),
    ),
  );
}
```

Which when run prints

```
flutter: Build List
flutter: Build Item 0
flutter: Build Item 1
flutter: Build Item 2
// After updating item 0 in the todoListProvider by pressing the FloatingActionButton
// you will then see:
flutter: Build Item 3
```

This approach comes with some nice organizational properties,
such as keeping your widget constructors clean from an ever growing list of parameters being passed down.

## Scoping Dependent Providers

In the previous example no other provider depended on the `todoItemIndexProvider`.

Let's change the example to use a dependent provider rather than a family.

This:

```dart
/// Provides a single todo, so you can watch them individually
///
/// This way you will only be notified if the particular todo you
/// were watching was updated
final todoProvider = Provider.family<Todo, int>(
    (ref, index) => ref.watch(todoListProvider).state[index]);
```

changes to:

```dart
/// Provides a single todo based on the todoItemIndexProvider
final todoProvider = Provider<Todo>(
    (ref) => ref.watch(todoListProvider).state[ref.watch(todoItemIndexProvider)]);
```

and this:

```dart
/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Gets the index of this particular Todo
    final index = ref.watch(todoItemIndexProvider);
    print('Building Item $index');
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider(index));
    // Display it!
    return Text(todoItem.todo);
  }
}
```

changes to:

```dart
/// A widget to show a single todo
class TodoWidget extends ConsumerWidget {
  const TodoWidget();
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watches a single todo item
    final todoItem = ref.watch(todoProvider);
    // Display it!
    return Text(todoItem.todo);
  }
}
```

Well if we try this with no other changes, we get an exception thrown!

````
══╡ EXCEPTION CAUGHT BY WIDGETS LIBRARY ╞═══════════════════════════════════════════════════════════
The following assertion was thrown building TodoWidget(dirty, dependencies:
[UncontrolledProviderScope], state: _ConsumerState#b120a):
Tried to read Provider<Todo>#63871 from a place where one of its dependencies were overridden but
the provider is not.

To fix this error, you can add add "dependencies" to Provider<Todo>#63871 such that we have:

 ```
final a = Provider(...);
final b = Provider((ref) => ref.watch(a), dependencies: [a]);
 ```
'package:riverpod/src/framework/container.dart':
Failed assertion: line 479 pos 15: 'targetElement.provider != targetElement.origin ||
                  dependencyElement ==
                      targetElement.container
                          .readProviderElement<Object?>(dependency)'

The relevant error-causing widget was:
  TodoWidget 
````

The problem is that riverpod does not know which scope to insert the
new `todoProvider` that you are trying to access in `TodoWidget`. By
default it places all providers in the root scope at the root of your
widget tree. This way you can access the same provider from all parts
of your app. But in that scope the `todoItemIndexProvider` provider is not overridden otherwise
you'd have the same todo index for the whole app.

The solution to this problem is to tell riverpod override the `todoProvider` for the subtree as well by 
adding the `todoItemIndexProvider` to a dependency list for the `todoProvider`.

When using scoped dependencies `todoProvider` we need to specify *all* of the providers our provider depends on
so that Riverpod when overriding a provider which dependent providers also need overrides.

```dart
/// Provides a single todo based on the todoItemIndexProvider
final todoProvider = Provider<Todo>(
    (ref) => ref.watch(todoListProvider).state[ref.watch(todoItemIndexProvider)],
  dependencies: [todoItemIndexProvider, todoListProvider]
);
```

Now you have a scoped provider!

[ProviderContainer]: https://pub.dev/documentation/riverpod/latest/riverpod/ProviderContainer-class.html
[providerscope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/ProviderScope-class.html
[UncontrolledProviderScope]: https://pub.dev/documentation/flutter_riverpod/latest/flutter_riverpod/UncontrolledProviderScope-class.html
